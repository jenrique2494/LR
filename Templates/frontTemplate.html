<article class="card">
  <!-- Card Header: Word Display -->
  <header class="card-header">
    <h1 class="word">{{Word}}</h1>
    <div class="badges-container">
      <span class="pos-badge {{^Part of Speech}}is-empty{{/Part of Speech}}">
        {{#Part of Speech}}{{Part of Speech}}{{/Part of Speech}} 
        {{^Part of Speech}}&nbsp;{{/Part of Speech}}
      </span>
      <span class="level-badge" data-level="{{Tags}}">{{Tags}}</span>
    </div>
    <span class="audio-button word-audio-button"></span>
    <span class="audio-button word-audio-button-anki"></span>
    <button class="copy-card-button" title="Copiar texto de la tarjeta">
    </button>
  </header>

  <!-- Pronunciation and Audio -->
  <section class="pronunciation-audio">
    <span class="pronunciation">/{{Pronunciation/IPA}}/</span>
  </section>

  <hr class="divider" />

  <!-- Example Sentences Section -->
  <section class="examples-section">
    <h2 class="section-title">Examples</h2>
    <ul class="examples-list">
      {{#Example 1}}
      <li class="example-item">{{Example 1}}</li>
      {{/Example 1}} {{#Example 2}}
      <li class="example-item">{{Example 2}}</li>
      {{/Example 2}} {{#Example 3}}
      <li class="example-item">{{Example 3}}</li>
      {{/Example 3}}
    </ul>
  </section>

  <script>
    (function() {
      // Variables globales para manejar auto-reproducci√≥n
      let front_pendingAutoplay = null;
      let front_hasUserInteracted = false;
      let front_hasAutoPlayed = false; // Flag to prevent multiple autoplay attempts

      // Funci√≥n para detectar primera interacci√≥n del usuario
      function front_setupAutoplayOnFirstInteraction() {
        const events = ['click', 'touchstart', 'keydown', 'mousemove'];
        
        const handleFirstInteraction = () => {
          front_hasUserInteracted = true;
          front_debugLog('üëÜ Primera interacci√≥n del usuario detectada', 'success');
          
          // Si hay un audio pendiente, reproducirlo ahora
          if (front_pendingAutoplay && front_pendingAutoplay.audio) {
            front_debugLog('üîÑ Reproduciendo audio pendiente tras interacci√≥n del usuario');
            front_pendingAutoplay.audio.play().then(() => {
              front_debugLog('‚úÖ Audio TikTok reproduci√©ndose tras interacci√≥n', 'success');
            }).catch(error => {
              front_debugLog(`‚ùå Error reproduciendo audio tras interacci√≥n: ${error.message}`, 'error');
            });
            front_pendingAutoplay = null;
          }
          
          // Remover listeners ya que solo necesitamos la primera interacci√≥n
          events.forEach(event => {
            document.removeEventListener(event, handleFirstInteraction, true);
          });
        };
        
        // Agregar listeners para todos los tipos de interacci√≥n
        events.forEach(event => {
          document.addEventListener(event, handleFirstInteraction, true);
        });
        
        front_debugLog('üëÇ Listeners de primera interacci√≥n configurados');
      }

      // Debug panel para monitorear el estado del audio
      function front_createDebugPanel() {

        // if (document.getElementById('audio-debug-panel')) {
        //   return;
        // }
        
        // const debugPanel = document.createElement('div');
        // debugPanel.id = 'audio-debug-panel';
        // debugPanel.style.cssText = `
        //   position: fixed !important;
        //   top: 10px !important;
        //   right: 10px !important;
        //   background: rgba(0,0,0,0.9) !important;
        //   color: white !important;
        //   padding: 10px !important;
        //   border-radius: 5px !important;
        //   font-family: monospace !important;
        //   font-size: 12px !important;
        //   max-width: 300px !important;
        //   z-index: 99999 !important;
        //   max-height: 400px !important;
        //   overflow-y: auto !important;
        //   border: 2px solid #00ff00 !important;
        // `;
        // debugPanel.innerHTML = `
        //   <div style="font-weight: bold; margin-bottom: 5px; color: #00ff00;">üéµ Audio Debug Panel</div>
        //   <div id="debug-content"></div>
        //   <button onclick="clearDebugLog()" style="margin-top: 5px; padding: 2px 5px; background: #333; color: white; border: 1px solid #666;">Clear Log</button>
        // `;
        // document.body.appendChild(debugPanel);
        
        // // Log inmediato para confirmar que se cre√≥
        // setTimeout(() => {
        //   debugLog('‚úÖ Panel de debug creado y agregado al DOM', 'success');
        // }, 100);
      }

      function front_debugLog(message, type = 'info') {
        const timestamp = new Date().toLocaleTimeString();
        const debugContent = document.getElementById('debug-content');
        if (debugContent) {
          const logEntry = document.createElement('div');
          logEntry.style.cssText = `
            margin: 2px 0;
            padding: 2px;
            border-left: 3px solid ${type === 'error' ? 'red' : type === 'success' ? 'green' : type === 'warning' ? 'orange' : 'cyan'};
            padding-left: 5px;
          `;
          logEntry.innerHTML = `<span style="color: gray;">[${timestamp}]</span> ${message}`;
          debugContent.appendChild(logEntry);
          debugContent.scrollTop = debugContent.scrollHeight;
        }
        console.log(`[Audio Debug] ${message}`);
      }

      function front_clearDebugLog() {
        const debugContent = document.getElementById('debug-content');
        if (debugContent) {
          debugContent.innerHTML = '';
        }
      }

      // Hacer la funci√≥n global para que funcione desde el HTML
      window.front_clearDebugLog = front_clearDebugLog;

      function front_cleanExampleSentenceForCoca(sentenceHTML) {
        if (typeof sentenceHTML !== "string" || !sentenceHTML) return "";

        let cleaned = sentenceHTML;

        cleaned = cleaned.replace(/\[.*?\]/g, "");

        const equalsIndex = cleaned.indexOf("=");
        if (equalsIndex !== -1) {
          cleaned = cleaned.substring(0, equalsIndex);
        }

        cleaned = cleaned.replace(/\s+/g, " ");
        return cleaned.trim();
      }

      // Function to set up copy card button functionality
      function front_setupCopyCardButton() {
        front_debugLog('üéØ Configurando bot√≥n de copiar texto de tarjeta');
        
        const copyButton = document.querySelector('.copy-card-button');
        if (!copyButton) {
          front_debugLog('‚ùå No se encontr√≥ el bot√≥n de copiar', 'error');
          return;
        }
        
        copyButton.addEventListener('click', async (e) => {
          e.preventDefault();
          front_debugLog('üñ±Ô∏è Click en bot√≥n de copiar texto');
          
          try {
            // Extract only the relevant text content (word, definition, examples)
            const wordElement = document.querySelector('.word');
            const exampleElements = document.querySelectorAll('.example-item');
            
            let textToCopy = '';
            
            // Add word
            if (wordElement) {
              const wordText = wordElement.textContent || wordElement.innerText || '';
              if (wordText.trim()) {
                textToCopy += `Word: ${wordText.trim()}\n\n`;
              }
            }
            
            // Add examples (front template shows examples only)
            if (exampleElements.length > 0) {
              textToCopy += 'Examples:\n';
              exampleElements.forEach((element, index) => {
                const exampleText = element.textContent || element.innerText || '';
                if (exampleText.trim()) {
                  // Clean up example text (remove extra whitespace, brackets, etc.)
                  let cleanText = exampleText.trim();
                  cleanText = cleanText.replace(/\[.*?\]/g, ''); // Remove bracketed content
                  cleanText = cleanText.replace(/\s+/g, ' '); // Normalize whitespace
                  cleanText = cleanText.trim();
                  
                  if (cleanText) {
                    textToCopy += `${index + 1}. ${cleanText}\n`;
                  }
                }
              });
            }
            
            // Copy to clipboard
            if (textToCopy.trim()) {
              await navigator.clipboard.writeText(textToCopy.trim());
              front_debugLog('‚úÖ Texto copiado al portapapeles', 'success');
              
              // Visual feedback
              const originalHTML = copyButton.innerHTML;
              copyButton.innerHTML = `
                <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor">
                  <path d="M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z"/>
                </svg>
              `;
              copyButton.style.color = '#4CAF50';
              
              setTimeout(() => {
                copyButton.innerHTML = originalHTML;
                copyButton.style.color = '';
              }, 1500);
              
            } else {
              front_debugLog('‚ö†Ô∏è No hay texto relevante para copiar', 'warning');
            }
            
          } catch (error) {
            front_debugLog(`‚ùå Error copiando texto: ${error.message}`, 'error');
            
            // Visual feedback for error
            const originalHTML = copyButton.innerHTML;
            copyButton.innerHTML = `
              <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor">
                <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
              </svg>
            `;
            copyButton.style.color = '#f44336';
            
            setTimeout(() => {
              copyButton.innerHTML = originalHTML;
              copyButton.style.color = '';
            }, 1500);
          }
        });
        
        front_debugLog('‚úÖ Bot√≥n de copiar configurado correctamente');
      }

      function front_highlightWordInExamples() {
        const wordElement = document.querySelector(".word");
        if (!wordElement) return;

        const targetWord = wordElement.textContent || wordElement.innerText || "";
        if (!targetWord) return;

        const cleanWord = targetWord.toLowerCase().trim();
        if (!cleanWord) return;

        // Helpers
        const escapeRegex = (s) => s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

        // Produce umlaut variants: a->√§, o->√∂, u->√º and also ae->√§, oe->√∂, ue->√º
        const umlautVariants = (w) => {
          const variants = new Set([w]);
          if (w.includes('ae')) variants.add(w.replace(/ae/g, '√§'));
          if (w.includes('oe')) variants.add(w.replace(/oe/g, '√∂'));
          if (w.includes('ue')) variants.add(w.replace(/ue/g, '√º'));
          if (w.includes('a')) variants.add(w.replace(/a/g, '√§'));
          if (w.includes('o')) variants.add(w.replace(/o/g, '√∂'));
          if (w.includes('u')) variants.add(w.replace(/u/g, '√º'));
          return Array.from(variants);
        };

        const generateVariations = (word) => {
          const variations = new Set();
          const lower = word;
          const capitalized = word.charAt(0).toUpperCase() + word.slice(1);

          variations.add(lower);
          variations.add(capitalized);

          // Base stem guesses for verbs (remove common infinitive endings)
          let stem = lower;
          if (stem.endsWith('en')) stem = stem.slice(0, -2);
          else if (stem.endsWith('n')) stem = stem.slice(0, -1);

          // Common German plural endings and genitive
          const plurals = ['s', 'e', 'en', 'n', 'er', 'ern', 'es'];
          plurals.forEach(p => {
            variations.add(stem + p);
            variations.add(lower + p);
          });

          // Diminutives
          ['chen', 'lein'].forEach(d => {
            variations.add(stem + d);
            variations.add(lower + d);
          });

          // Adjective/noun endings (cases)
          ['','e','en','em','er','es'].forEach(suffix => {
            variations.add(lower + suffix);
            variations.add(capitalized + suffix);
          });

          // Comparative / superlative
          variations.add(lower + 'er');
          variations.add(lower + 'ste');
          variations.add(lower + 'sten');

          // Verb conjugation common endings (ich/du/er/wir/ihr/sie)
          ['e','st','t','en','t','en'].forEach(ending => variations.add(stem + ending));

          // Past participle and simple past heuristic
          variations.add('ge' + stem + 't');
          variations.add('ge' + stem + 'en');
          variations.add(stem + 'te');
          variations.add(stem + 'te');

          // Possessive/genitive short forms
          variations.add(lower + 's');
          variations.add(lower + 'es');

          // Agent / nominalized forms
          ['er','erin','ung','keit','heit','schaft','tum'].forEach(suf => variations.add(stem + suf));

          // Add umlaut variants for reasonable matches
          Array.from(variations).forEach(v => {
            umlautVariants(v).forEach(u => variations.add(u));
          });

          // Add uppercase variants for sentence starts and nouns
          const originals = Array.from(variations);
          originals.forEach(v => {
            if (v && v.length > 0) {
              variations.add(v.charAt(0).toUpperCase() + v.slice(1));
              variations.add(v.toUpperCase());
            }
          });

          return Array.from(variations).filter(Boolean);
        };

        const wordVariations = generateVariations(cleanWord);

        // Build safe regex patterns; use word boundaries but allow matching inside compounds optionally
        const exactPattern = "\\b(" + wordVariations.map(v => escapeRegex(v)).join("|") + ")\\b";
        const exactRegex = new RegExp(exactPattern, "gi");

        const partialPattern = "(" + wordVariations.map(v => escapeRegex(v)).join("|") + ")";
        const partialRegex = new RegExp(partialPattern, "gi");

        document.querySelectorAll('.example-item').forEach((item) => {
          const originalHTML = item.innerHTML;

          // Skip if already contains <em> and try to preserve existing highlights
          if (item.querySelector('em')) {
            const emTags = [];
            let tempHTML = originalHTML.replace(/<em[^>]*>.*?<\/em>/gi, (match) => {
              const placeholder = `__EM_PLACEHOLDER_${emTags.length}__`;
              emTags.push(match);
              return placeholder;
            });

            tempHTML = tempHTML.replace(exactRegex, '<em>$1</em>');

            emTags.forEach((tag, index) => {
              tempHTML = tempHTML.replace(`__EM_PLACEHOLDER_${index}__`, tag);
            });

            if (originalHTML !== tempHTML) item.innerHTML = tempHTML;
          } else {
            // Try exact word-boundary matches first
            let highlightedHTML = originalHTML.replace(exactRegex, '<em>$1</em>');

            // If no exact matches, try partial/compound matching but avoid very short matches
            if (originalHTML === highlightedHTML) {
              const textContent = (item.textContent || item.innerText || '').toLowerCase();
              const words = textContent.split(/\s+/);
              const hasCompoundMatch = words.some(w =>
                wordVariations.some(variant => variant.length >= 3 && w.includes(variant) && w !== variant && w.length > variant.length + 1)
              );

              if (hasCompoundMatch) {
                highlightedHTML = originalHTML.replace(partialRegex, '<em>$1</em>');
              }
            }

            if (originalHTML !== highlightedHTML) item.innerHTML = highlightedHTML;
          }
        });
      }

      function front_processLevelBadge() {
        const levelBadge = document.querySelector('.level-badge');
        if (!levelBadge) return;
        
        const tagsContent = levelBadge.textContent || levelBadge.innerText || '';
        if (!tagsContent) {
          levelBadge.style.display = 'none';
          return;
        }
        
        // Extract all levels from tags (A1, A2, B1, B2, C1, C2, duplicate)
        const levels = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'duplicate'];
        const foundLevels = levels.filter(level => 
          tagsContent.toLowerCase().includes(level.toLowerCase())
        );
        
        if (foundLevels.length === 0) {
          levelBadge.style.display = 'none';
          return;
        }
        
        // Clear the original badge content
        levelBadge.innerHTML = '';
        
        // Create individual badges for each found level
        foundLevels.forEach((level, index) => {
          const badge = document.createElement('span');
          badge.textContent = level.toUpperCase();
          badge.className = `level-badge level-${level.toLowerCase()}`;
          
          // Add some spacing between badges if there are multiple
          if (index > 0) {
            badge.style.marginLeft = '4px';
          }
          
          levelBadge.appendChild(badge);
        });
        
        // Remove the original level-badge class since we're using it as a container now
        levelBadge.className = 'level-badges-container';
      }

      function front_applyCocaExampleCleaning() {
        const exampleItems = document.querySelectorAll(
          "article.card .examples-section .example-item"
        );
        exampleItems.forEach((item) => {
          if (item.innerHTML) {
            const originalHTML = item.innerHTML;
            const cleanedHTML = front_cleanExampleSentenceForCoca(originalHTML);
            if (originalHTML !== cleanedHTML) {
              item.innerHTML = cleanedHTML;
            }
          }
        });
      }


      // ===================================================================
      // FUNCI√ìN DE VERIFICACI√ìN (TIMEOUT ACTUALIZADO A 700ms)
      // ===================================================================

      /**
       * Realiza una serie de pruebas de red para determinar de forma fiable si el usuario est√° offline.
       * Devuelve una promesa que se resuelve a `true` si est√° offline, o `false` si est√° online.
       */
      async function front_isReallyOffline() {
          
          // --- Funci√≥n auxiliar para pruebas con "Image Ping" (evita CORS) ---
          const imagePingTest = (url) => {
              return () => new Promise((resolve, reject) => {
                  const img = new Image();
                  let timedOut = false;

                  const timeout = setTimeout(() => {
                      timedOut = true;
                      img.onload = null;
                      img.onerror = null;
                      reject(new Error(`Timeout al cargar la imagen: ${url}`));
                  }, 700); // <-- CAMBIO AQU√ç: Timeout de 0.7 segundos

                  img.onload = () => {
                      if (timedOut) return;
                      clearTimeout(timeout);
                      resolve(new Response(null, { status: 200 }));
                  };

                  img.onerror = () => {
                      if (timedOut) return;
                      clearTimeout(timeout);
                      reject(new Error(`Error al cargar la imagen: ${url}`));
                  };
                  img.src = `${url}?_=${Date.now()}`;
              });
          };

          // --- Array de todas las pruebas ---
          const connectivityTests = [
              imagePingTest('https://www.google.com/favicon.ico'),
              imagePingTest('https://www.cloudflare.com/favicon.ico'),
              () => fetch('https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js', {
                  method: 'HEAD',
                  cache: 'no-cache',
                  signal: AbortSignal.timeout(700) // <-- CAMBIO AQU√ç: Timeout de 0.7 segundos
              })
          ];

          // --- L√≥gica principal de la funci√≥n ---
          // Envolvemos Promise.any en otra promesa para controlar el valor de retorno
          return new Promise(resolve => {
              Promise.any(connectivityTests.map(test => test()))
                  .then(() => {
                      // Si CUALQUIER prueba tiene √©xito, estamos online.
                      resolve(false); // Resolvemos con `false` (no estamos offline)
                  })
                  .catch(() => {
                      // Si TODAS las pruebas fallan, estamos offline.
                      resolve(true); // Resolvemos con `true` (s√≠ estamos offline)
                  });
          });
      }
      async function front_setWordTTS() {
        front_debugLog('üéØ Iniciando configuraci√≥n de TTS', 'info');

        front_isReallyOffline().then(offline => {
          // Este c√≥digo dentro del .then() se ejecutar√° m√°s tarde,
          // cuando la comprobaci√≥n termine (despu√©s de un m√°ximo de 0.7 segundos).
          // condicional para ver si ya audioButtonAnki ya tiene elementos adentro 
          if (offline && audioButtonAnki.innerHTML.trim() === '') {
              front_debugLog('üåê Fetch remoto fall√≥, sin conexi√≥n real', 'warning');
              front_debugLog('üåê Sin conexi√≥n: mostrando TTS nativo de Anki', 'success');
              // const voz='{tts en_US voices=Microsoft_Zira:Word}';
              // audioButtonAnki.innerHTML = `<span style="display:block">{tts en_GB voices=com.google.android.tts-en-GB-language:Word}</span>`;
              

              // El 'return' aqu√≠ solo saldr√≠a de la funci√≥n .then(), no de la funci√≥n principal.
              // Si necesitas detener algo m√°s, la l√≥gica deber√≠a ir aqu√≠ dentro.
          }else{
              front_debugLog('üåê Conexi√≥n verificada: procediendo con TTS remoto', 'success');
          }
        });
       
        const ttsConfig = {
          domain: [
            "https://anki-eng.0w0.live/",
            "https://ms-ra-forwarder-for-ifreetime-v9q1.vercel.app/",
          ],
          params: {
            speed: -4,
          },
        };

        // Configuraci√≥n alternativa de TikTok TTS
        const tiktokTTSConfig = {
          url: "https://tiktok-tts.weilnet.workers.dev/api/generation",
          headers: {
            'accept': '*/*',
            'accept-language': 'en-US,en-GB;q=0.9,en;q=0.8',
            'cache-control': 'no-cache',
            'content-type': 'application/json',
            'origin': 'https://free-tts.com',
            'pragma': 'no-cache',
            'referer': 'https://free-tts.com/',
            'sec-ch-ua': '"Not;A=Brand";v="99", "Google Chrome";v="139", "Chromium";v="139"',
            'sec-ch-ua-mobile': '?0',
            'sec-ch-ua-platform': '"Windows"',
            'sec-fetch-dest': 'empty',
            'sec-fetch-mode': 'cors',
            'sec-fetch-site': 'cross-site',
            'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36'
          }
        };

        // Lista completa de voces Azure
        const voices = [
          "en-US-AriaNeural",
          "en-US-EmmaNeural",
          "en-US-JennyNeural",
          "en-US-ChristopherNeural",
          "en-US-EricNeural",
          "en-US-MichelleNeural",
          "en-US-SteffanNeural",
          "en-US-RogerNeural",
          "en-GB-SoniaNeural",
          "en-GB-LibbyNeural",
          "en-GB-RyanNeural",
          "en-GB-ThomasNeural",
          "en-AU-NatashaNeural",
          "en-AU-WilliamNeural",
          "en-CA-ClaraNeural",
          "en-CA-LiamNeural",
          "en-IN-NeerjaNeural",
          "en-IN-PrabhatNeural",
          "en-IE-ConnorNeural",
          "en-IE-EmilyNeural",
        ];

        // Voces de TikTok TTS como respaldo
        const tiktokVoices = [
          "en_us_001", // English US - Female 1
          "en_us_002", // English US - Female 2
          "en_us_006", // English US - Male 1
          "en_us_007", // English US - Male 2
          "en_us_009", // English US - Male 3
          "en_us_010", // English US - Male 4
          "en_uk_001", // English UK - Male 1
          "en_uk_003", // English UK - Male 2
          "en_au_001", // English AU - Female
          "en_au_002", // English AU - Male
          "en_male_narration", // Narrator
          "en_female_emotional", // Peaceful
          "en_male_cody", // Serious
        ];
        // Elegir 3 voces aleatorias distintas
        function getRandomVoices(arr, n) {
          const copy = arr.slice();
          const result = [];
          for (let i = 0; i < n && copy.length > 0; i++) {
            const idx = Math.floor(Math.random() * copy.length);
            result.push(copy.splice(idx, 1)[0]);
          }
          return result;
        }

        // Array that defines the order of TTS services to try
        const ttsServiceOrder = ['streamelements', 'tiktok', 'azure'];
        
        // Set to track permanently failed TTS services
        const failedServices = new Set();

        // StreamElements TTS voices (using English voice names from voices.json)
        const streamElementsVoices = [
          "Vicki",
          "Marlene",
          "Hans",
          "de-DE-Standard-A", 
          "de-DE-Standard-B", 
          "Michael",
          "Karsten",
        ];
       
        // Voice arrays for each service
        const serviceVoices = {
          streamelements: getRandomVoices(streamElementsVoices, 3),
          azure: getRandomVoices(voices, 3),
          tiktok: getRandomVoices(tiktokVoices, 3)
        };
        
        let currentVoiceIdx = 0;

        front_debugLog(`üìù TTS Service Order: ${ttsServiceOrder.join(' ‚Üí ')}`);
        front_debugLog(`üìù Voces StreamElements seleccionadas: ${serviceVoices.streamelements.join(', ')}`);
        front_debugLog(`üìù Voces Azure seleccionadas: ${serviceVoices.azure.join(', ')}`);
        front_debugLog(`üìù Voces TikTok seleccionadas: ${serviceVoices.tiktok.join(', ')}`);

        const word = document.querySelector(".word")?.textContent?.trim();
        const audioButton = document.querySelector(".word-audio-button");
        const audioButtonAnki=document.querySelector(".word-audio-button-anki");
        
        if (!word) {
          front_debugLog('‚ùå No se encontr√≥ la palabra en el elemento .word', 'error');
          return;
        }
        if (!audioButton) {
          front_debugLog('‚ùå No se encontr√≥ el bot√≥n de audio .word-audio-button', 'error');
          return;
        }
        
        front_debugLog(`üéØ Palabra encontrada: "${word}"`);
        front_debugLog(`üéØ Bot√≥n de audio encontrado`);

        // Helper function to get available services (not failed)
        function getAvailableServices() {
          return ttsServiceOrder.filter(service => !failedServices.has(service));
        }

        // Function to create StreamElements TTS audio
        async function createStreamElementsAudio(text, voiceIndex) {
          const voiceName = serviceVoices.streamelements[voiceIndex];
          front_debugLog(`üü¢ Intentando StreamElements TTS para "${text}" con voz: ${voiceName} (√≠ndice: ${voiceIndex})`);
          
          try {
            const url = `https://api.streamelements.com/kappa/v2/speech?voice=${encodeURIComponent(voiceName)}&text=${encodeURIComponent(text)}`;
            front_debugLog(`üîó URL StreamElements: ${url}`);
            
            // Test the StreamElements API
            const timeoutPromise = new Promise((_, reject) => {
              setTimeout(() => reject(new Error('StreamElements timeout after 4 seconds')), 4000);
            });
            
            const fetchPromise = fetch(url, {
              method: 'HEAD',
              cache: 'no-cache'
            });
            
            const response = await Promise.race([fetchPromise, timeoutPromise]);
            front_debugLog(`üì° Respuesta StreamElements: ${response.status} ${response.statusText}`);
            
            if (response.ok && response.status === 200) {
              const contentType = response.headers.get('content-type');
              const contentLength = response.headers.get('content-length');
              
              front_debugLog(`üìÑ StreamElements Content-Type: ${contentType}, Content-Length: ${contentLength}`);
              
              // Check if it's actually audio content
              if (contentType && 
                  (contentType.includes('audio') || contentType.includes('mpeg') || contentType.includes('mp3'))) {
                
                front_debugLog(`‚úÖ StreamElements TTS verificado como funcional`, 'success');
                
                // Create audio element
                const audio = document.createElement("audio");
                audio.preload = "auto";
                audio.src = url;
                
                return audio;
              } else {
                throw new Error(`StreamElements invalid content: Type=${contentType}, Length=${contentLength}`);
              }
            } else {
              throw new Error(`StreamElements HTTP error: ${response.status} ${response.statusText}`);
            }
          } catch (error) {
            front_debugLog(`‚ùå Error StreamElements TTS: ${error.message}`, 'error');
            throw error;
          }
        }

        // Function to create Azure TTS audio
        async function createAzureAudio(text, voiceIndex) {
          const voiceName = serviceVoices.azure[voiceIndex];
          front_debugLog(`üîµ Intentando Azure TTS para "${text}" con voz: ${voiceName} (√≠ndice: ${voiceIndex})`);
          
          const queryString = new URLSearchParams({
            ...ttsConfig.params,
            text: text,
            voiceName,
          });

          // Test Azure endpoints to find working ones
          for (const [index, url] of ttsConfig.domain.entries()) {
            const fullUrl = `${url}api/aiyue?${queryString}`;
            front_debugLog(`üîó Probando Azure ${index + 1}: ${fullUrl}`);
            
            try {
              const timeoutPromise = new Promise((_, reject) => {
                setTimeout(() => reject(new Error('Azure TTS timeout after 2 seconds')), 2000);
              });
              
              const fetchPromise = fetch(fullUrl, {
                method: 'HEAD',
                cache: 'no-cache',
                headers: { 'Accept': 'audio/*' }
              });
              
              const response = await Promise.race([fetchPromise, timeoutPromise]);
              
              if (response.ok && response.status === 200) {
                const contentType = response.headers.get('content-type');
                const contentLength = response.headers.get('content-length');
                
                if (contentType && 
                    (contentType.includes('audio') || contentType.includes('mpeg') || contentType.includes('mp3')) &&
                    contentLength && parseInt(contentLength) > 1000) {
                  
                  front_debugLog(`‚úÖ Azure TTS ${index + 1} verificado como funcional`, 'success');
                  
                  // Create audio element with working sources
                  const audio = document.createElement("audio");
                  audio.preload = "none";
                  
                  ttsConfig.domain.forEach((sourceUrl, sourceIndex) => {
                    const source = document.createElement("source");
                    source.src = `${sourceUrl}api/aiyue?${queryString}`;
                    source.type = "audio/mpeg";
                    audio.appendChild(source);
                  });
                  
                  return audio;
                }
              }
            } catch (error) {
              front_debugLog(`‚ùå Azure ${index + 1} failed: ${error.message}`, 'error');
            }
          }
          
          throw new Error('All Azure TTS sources failed');
        }

        // Function to create TikTok TTS audio  
        async function createTiktokAudioElement(text, voiceIndex) {
          const voiceCode = serviceVoices.tiktok[voiceIndex];
          front_debugLog(`üü° Intentando TikTok TTS para "${text}" con voz: ${voiceCode} (√≠ndice: ${voiceIndex})`);
          
          const audioUrl = await createTiktokAudio(text, voiceCode);
          
          const audio = document.createElement("audio");
          audio.preload = "none";
          audio.src = audioUrl;
          
          return audio;
        }
        async function createTiktokAudio(text, voiceCode) {
          front_debugLog(`üöÄ Iniciando TikTok TTS para "${text}" con voz: ${voiceCode}`);
          try {
            const response = await fetch(tiktokTTSConfig.url, {
              method: 'POST',
              headers: tiktokTTSConfig.headers,
              body: JSON.stringify({
                text: text,
                voice: voiceCode
              })
            });

            front_debugLog(`üì° Respuesta TikTok TTS: ${response.status} ${response.statusText}`);

            if (!response.ok) {
              throw new Error(`TikTok TTS failed: ${response.status}`);
            }

            const responseData = await response.json();
            front_debugLog(`üì¶ Datos de respuesta TikTok TTS recibidos`);
            front_debugLog(`‚úÖ Success: ${responseData.success}, Error: ${responseData.error || 'none'}`);
            
            // Verificar si la respuesta fue exitosa
            if (responseData.success && responseData.data) {
              // La respuesta viene directamente en el campo 'data' como base64
              const audioBase64 = responseData.data;
              front_debugLog(`üìä Tama√±o del audio base64: ${audioBase64.length} caracteres`);
              
              // Convertir base64 a blob
              const binaryString = atob(audioBase64);
              const bytes = new Uint8Array(binaryString.length);
              for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
              }
              
              const audioBlob = new Blob([bytes], { type: 'audio/mpeg' });
              const audioUrl = URL.createObjectURL(audioBlob);
              
              front_debugLog(`‚úÖ TikTok TTS audio creado exitosamente con voz: ${voiceCode}`, 'success');
              front_debugLog(`üîó URL del audio: ${audioUrl.substring(0, 50)}...`);
              return audioUrl;
            } else {
              throw new Error(`TikTok TTS API error: ${responseData.error || 'Unknown error'}`);
            }
          } catch (error) {
            front_debugLog(`‚ùå Error en TikTok TTS: ${error.message}`, 'error');
            throw error;
          }
        }
        // Bot√≥n de audio
        front_debugLog('üîß Creando bot√≥n de audio');
        audioButton.innerHTML = "";
        audioButton.insertAdjacentHTML(
          "beforeend",
          '<a class="tts-button audio-button soundLink"><svg viewBox="0 0 24 24"><path d="M5.25 9v6h4l5 5V4L9.25 9H5.25z M18.75 12c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z"/></svg></a>'
        );
        const ttsBtn = audioButton.querySelector(".tts-button");
        front_debugLog('‚úÖ Bot√≥n de audio creado');
        
        // Add double-click event to the word element to trigger audio playback
        // Use a more targeted approach to prevent listener accumulation
        const wordElement = document.querySelector('.card');
        if (wordElement && ttsBtn) {
          // Create a unique handler for this specific TTS button instance
          const cardInstanceId = 'card-instance-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
          
          // Store reference to this specific button in a data attribute
          ttsBtn.setAttribute('data-instance-id', cardInstanceId);
          
          const handleDoubleClick = function(e) {
            // Find the TTS button that belongs to this card
            const targetTtsBtn = e.currentTarget.querySelector('.word-audio-button .tts-button');
            
            // Only proceed if we found a button and it's still the current instance
            if (targetTtsBtn && targetTtsBtn.getAttribute('data-instance-id')) {
              front_debugLog('üñ±Ô∏è Doble click en la tarjeta, reproduciendo audio de instancia actual');
              targetTtsBtn.click();
            } else {
              front_debugLog('‚ö†Ô∏è Doble click detectado pero no hay bot√≥n TTS v√°lido');
            }
          };
          
          // Remove any previous listeners of this type using a custom event namespace
          if (wordElement._doubleClickHandler) {
            wordElement.removeEventListener('dblclick', wordElement._doubleClickHandler);
            front_debugLog('üßπ Removido listener anterior');
          }
          
          // Store the handler reference for future cleanup
          wordElement._doubleClickHandler = handleDoubleClick;
          wordElement.addEventListener('dblclick', handleDoubleClick);
          
          front_debugLog(`‚úÖ Listener de doble click configurado para instancia ${cardInstanceId}`);
        }

        // Main function to create TTS audio using service order
        async function createCurrentVoiceAudio() {
          front_debugLog('üéµ Iniciando creaci√≥n de audio con service order');
          
          // Pause and completely stop ALL existing audios
          const existingAudios = document.querySelectorAll("article.card audio");
          front_debugLog(`‚è∏Ô∏è Pausando y reseteando ${existingAudios.length} audios existentes`);
          existingAudios.forEach((a) => {
            a.pause();
            a.currentTime = 0;
            // Clear any pending operations
            a.load();
          });
          
          // Wait a bit to ensure all audios are fully stopped
          await new Promise(resolve => setTimeout(resolve, 100));
          
          // Remove previous audio if exists
          const prevAudio = audioButton.querySelector("audio");
          if (prevAudio) {
            front_debugLog('üóëÔ∏è Eliminando audio anterior');
            prevAudio.pause();
            prevAudio.currentTime = 0;
            prevAudio.remove();
          }

          const availableServices = getAvailableServices();
          if (availableServices.length === 0) {
            front_debugLog('‚ùå No hay servicios TTS disponibles', 'error');
            return;
          }

          front_debugLog(`üîÑ Servicios disponibles: ${availableServices.join(', ')}`);

          // Try each service in order
          for (const service of availableServices) {
            try {
              front_debugLog(`ÔøΩ Intentando servicio: ${service}`);
              let audio;

              if (service === 'streamelements') {
                audio = await createStreamElementsAudio(word, currentVoiceIdx);
              } else if (service === 'tiktok') {
                audio = await createTiktokAudioElement(word, currentVoiceIdx);
              } else if (service === 'azure') {
                audio = await createAzureAudio(word, currentVoiceIdx);
              } else {
                front_debugLog(`‚ùå Servicio desconocido: ${service}`, 'error');
                continue;
              }

              // Add event listeners for monitoring
              audio.addEventListener('error', (e) => {
                front_debugLog(`‚ùå Error ${service} durante reproducci√≥n: ${e.type}`, 'error');
              });
              
              audio.addEventListener('loadstart', () => {
                front_debugLog(`üì° ${service} audio: loadstart detectado`);
              });
              
              audio.addEventListener('canplaythrough', () => {
                front_debugLog(`‚úÖ ${service} audio: canplaythrough - listo para reproducir`, 'success');
              });

              audioButton.insertBefore(audio, ttsBtn);
              front_debugLog(`üìΩÔ∏è Audio ${service} insertado en el DOM`, 'success');

              // Auto-play for first load only - but let playAllAudiosSequentially handle it
              if (currentVoiceIdx === 0 && !front_hasAutoPlayed) {
                front_debugLog(`üîÑ Audio ${service} preparado para auto-reproducci√≥n secuencial (carga inicial)`);
                
                // Don't play here - let playAllAudiosSequentially handle the initial playback
                // Just ensure the audio is ready
                const ensureReady = async () => {
                  if (audio.readyState >= 2) { // HAVE_CURRENT_DATA
                    front_debugLog(`‚úÖ Audio ${service} listo para reproducci√≥n secuencial`, 'success');
                  } else {
                    front_debugLog(`‚è≥ Audio ${service} prepar√°ndose para reproducci√≥n secuencial...`);
                    setTimeout(ensureReady, 100);
                  }
                };
                
                setTimeout(ensureReady, 100);
              }

              return; // Success, exit the loop
            } catch (error) {
              front_debugLog(`‚ùå Error con servicio ${service}: ${error.message}`, 'error');
              front_debugLog(`üö´ Marcando ${service} como fallido permanentemente`);
              failedServices.add(service);
            }
          }

          // If all services failed
          front_debugLog('‚ùå Todos los servicios TTS fallaron', 'error');
          const silentAudio = document.createElement("audio");
          silentAudio.preload = "none";
          audioButton.insertBefore(silentAudio, ttsBtn);
          front_debugLog('üîá Audio silencioso creado como √∫ltimo recurso', 'warning');
        }
        front_debugLog('üéØ Creando audio inicial');
        await createCurrentVoiceAudio(); // Wait for audio creation to complete
        
        ttsBtn.addEventListener("click", async (e) => {
          e.preventDefault();
          front_debugLog('üñ±Ô∏è Click en bot√≥n de audio');
          
          // First, immediately stop ALL audios to prevent conflicts
          document.querySelectorAll("article.card audio").forEach((a) => {
            a.pause();
            a.currentTime = 0;
          });
          
          // Get current service being used (first available service)
          const availableServices = getAvailableServices();
          if (availableServices.length === 0) {
            front_debugLog('‚ùå No hay servicios disponibles para cambiar voz', 'error');
            return;
          }
          
          const currentService = availableServices[0]; // We use the first available service
          const currentVoices = serviceVoices[currentService];
          
          // Change to next voice index
          const oldVoiceIdx = currentVoiceIdx;
          currentVoiceIdx = (currentVoiceIdx + 1) % currentVoices.length;
          front_debugLog(`üîÑ Cambiando voz ${currentService}: ${currentVoices[oldVoiceIdx]} ‚Üí ${currentVoices[currentVoiceIdx]}`);
          
          const prevAudio = audioButton.querySelector("audio");
          if (prevAudio) {
            front_debugLog('üóëÔ∏è Removiendo audio anterior del click');
            prevAudio.pause();
            prevAudio.currentTime = 0;
            prevAudio.remove();
          }
          
          // Wait a moment to ensure cleanup is complete
          await new Promise(resolve => setTimeout(resolve, 100));
          
          await createCurrentVoiceAudio();
          
          const audio = audioButton.querySelector("audio");
          if (audio) {
            front_debugLog('‚ñ∂Ô∏è Intentando reproducir audio');
            
            // Double-check that all other audios are stopped
            document
              .querySelectorAll("article.card audio")
              .forEach((a) => {
                if (a !== audio) {
                  a.pause();
                  a.currentTime = 0;
                }
              });
            
            // Ensure current audio starts from beginning
            audio.currentTime = 0;
            
            try {
              await audio.play();
              front_debugLog('‚úÖ Audio reproduci√©ndose correctamente', 'success');
            } catch (playError) {
              front_debugLog(`‚ùå Error al reproducir audio: ${playError.message}`, 'error');
            }
          } else {
            front_debugLog('‚ùå No se encontr√≥ elemento de audio para reproducir', 'error');
          }
        });
        
        front_debugLog('‚úÖ Configuraci√≥n de TTS completada', 'success');
      }

      function front_playAllAudiosSequentially() {
        front_debugLog('üéµ Iniciando playAllAudiosSequentially');
        
        // Check if we're already in an autoplay sequence to prevent double execution
        if (window.sequenceInProgress) {
          front_debugLog('‚ö†Ô∏è Secuencia ya en progreso, saltando duplicado');
          return;
        }
        window.sequenceInProgress = true;
        
        // Pause and reset ALL audios first to prevent conflicts
        document.querySelectorAll("article.card audio").forEach((a) => {
          a.pause();
          a.currentTime = 0;
        });
        
        // Get audios directly (don't clone to preserve src)
        const audios = [];
        const wordAudio = document.querySelector(".word-audio-button audio");
        if (wordAudio) {
          audios.push({ element: wordAudio, type: 'word' });
          front_debugLog(`üéµ Audio de palabra encontrado: ${wordAudio.src ? 'con src' : 'sin src'}`);
          front_debugLog(`üîó Audio src: ${wordAudio.src ? wordAudio.src.substring(0, 50) + '...' : 'NO SRC'}`);
        }
        
        if (audios.length === 0) {
          front_debugLog('‚ö†Ô∏è No se encontraron audios para reproducir en secuencia');
          window.sequenceInProgress = false;
          return;
        }
        
        front_debugLog(`üéµ Iniciando reproducci√≥n secuencial de ${audios.length} audios`);
        let currentIndex = 0;
        let isSequencePlaying = false;
        
        const playNext = async () => {
          if (currentIndex >= audios.length || isSequencePlaying) {
            if (currentIndex >= audios.length) {
              front_debugLog('‚úÖ Reproducci√≥n secuencial completada');
              window.sequenceInProgress = false;
            }
            return;
          }
          
          isSequencePlaying = true;
          const audioData = audios[currentIndex];
          const currentAudio = audioData.element;
          
          front_debugLog(`üéµ Reproduciendo audio ${currentIndex + 1}/${audios.length} (${audioData.type})`);
          
          // Ensure all other audios are completely stopped
          audios.forEach((otherAudioData, otherIndex) => {
            if (otherIndex !== currentIndex) {
              const otherAudio = otherAudioData.element;
              if (!otherAudio.paused) {
                otherAudio.pause();
                otherAudio.currentTime = 0;
              }
            }
          });
          
          // Wait for audio to be ready
          const waitForReady = () => Promise.resolve();
          
          try {
            await waitForReady();
            
            // Ensure audio starts from beginning
            currentAudio.currentTime = 0;
            
            // Set up end listener before playing
            const onAudioEnded = () => {
              currentAudio.removeEventListener('ended', onAudioEnded);
              front_debugLog(`‚úÖ Audio ${currentIndex + 1} (${audioData.type}) termin√≥`);
              
              isSequencePlaying = false;
              currentIndex++;
              
              // Delay before next audio to prevent overlap
              setTimeout(playNext, 300);
            };
            
            currentAudio.addEventListener('ended', onAudioEnded);
            
            // Try to play
            await currentAudio.play();
            front_debugLog(`‚úÖ Audio ${currentIndex + 1} (${audioData.type}) reproduci√©ndose`);
            
            // Mark autoplay as successful only after successful play
            if (currentIndex === 0 && !front_hasAutoPlayed) {
              front_hasAutoPlayed = true;
              front_debugLog(`üéØ Auto-play exitoso - marcando hasAutoPlayed = true`, 'success');
            }
            
          } catch (error) {
            front_debugLog(`‚ö†Ô∏è Error reproduciendo audio ${currentIndex + 1}: ${error.message}`, 'warning');
            
            // Si es un error de auto-reproducci√≥n y no hemos interactuado, guardar para despu√©s
            if (error.message.includes('user didn\'t interact') && !front_hasUserInteracted) {
              front_debugLog(`üíæ Guardando audio ${currentIndex + 1} para reproducir tras interacci√≥n`);
              front_pendingAutoplay = { audio: currentAudio };
              front_setupAutoplayOnFirstInteraction();
              isSequencePlaying = false;
              window.sequenceInProgress = false;
              return; // Stop the sequence
            }
            
            // Continue with next audio if this one failed
            isSequencePlaying = false;
            currentIndex++;
            setTimeout(playNext, 100);
          }
        };
        
        // Start playback after ensuring all setup is complete
        setTimeout(playNext, 400);
      }

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", async function () {
          front_createDebugPanel();
          front_debugLog('üöÄ DOM Content Loaded - Iniciando aplicaci√≥n');
          front_setupAutoplayOnFirstInteraction(); // Configurar auto-reproducci√≥n
          front_setupCopyCardButton(); // Setup copy button
          front_processLevelBadge();
          front_applyCocaExampleCleaning();
          front_highlightWordInExamples();
          await front_setWordTTS(); // Wait for TTS setup to complete
          setTimeout(() => {
            front_debugLog('üéµ Ejecutando playAllAudiosSequentially');
            front_playAllAudiosSequentially();
          }, 100); // Reduced delay since audio is already ready
        });
      } else {
        (async () => {
          front_createDebugPanel();
          front_debugLog('üöÄ DOM ya cargado - Iniciando aplicaci√≥n');
          front_setupAutoplayOnFirstInteraction(); // Configurar auto-reproducci√≥n
          front_setupCopyCardButton(); // Setup copy button
          front_processLevelBadge();
          front_applyCocaExampleCleaning();
          front_highlightWordInExamples();
          await front_setWordTTS(); // Wait for TTS setup to complete
          setTimeout(() => {
            front_debugLog('üéµ Ejecutando playAllAudiosSequentially');
            front_playAllAudiosSequentially();
          }, 100); // Reduced delay since audio is already ready
        })();
      }
    })();
  </script>
</article>
